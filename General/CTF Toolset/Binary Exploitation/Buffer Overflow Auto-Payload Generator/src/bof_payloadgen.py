import argparse
from pwn import cyclic, cyclic_find

def generate_pattern(length: int):
    pattern = cyclic(length, n=4)
    print(pattern.decode())

def find_offset(value: str, length: int):
    try:
        offset = cyclic_find(value.encode(), n=4)
        if offset == -1:
            print("Pattern not found in generated sequence.")
        else:
            print(f"Offset: {offset}")
    except Exception:
        print("Error: Invalid input or encoding issue.")

def generate_payload(offset: int, arch: str):
    nop_sled = b"\x90" * offset
    print(nop_sled)
    print(f"Architecture: {arch} â€” use appropriate return address manually.")

def main():
    parser = argparse.ArgumentParser(description="Buffer Overflow Auto-Payload Generator")
    parser.add_argument("--pattern", type=int, help="Generate a cyclic pattern of given length")
    parser.add_argument("--offset", help="Crash value (e.g., 'Aa0A') or offset")
    parser.add_argument("--length", type=int, help="Pattern length used when finding offset")
    parser.add_argument("--payload", action="store_true", help="Generate a payload with calculated offset")
    parser.add_argument("--arch", choices=["x86", "x64"], default="x64", help="Target architecture")
    args = parser.parse_args()

    if args.pattern:
        generate_pattern(args.pattern)
    elif args.offset and args.length:
        find_offset(args.offset, args.length)
    elif args.payload and args.offset:
        try:
            offset = int(args.offset)
            generate_payload(offset, args.arch)
        except ValueError:
            print("Offset must be an integer.")
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
